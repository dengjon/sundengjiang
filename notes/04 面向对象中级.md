# 软件包

包的三个作用：

1. 区分相同名字的类
2. 当类很多时，使用包可以进行方便的管理
3. 控制访问范围

软件包的本质就是创建不同的文件夹来保存类

命名规范：

com.公司名.项目名.业务模块名，例如：`com.bjtu.oa.model;`

**常用包**

1. java.lang.* -- 默认引用，无须再导入
2. java.util.* -- 系统提供的工具包、工具类，例如`Scanner`
3. java.net.* -- 网络包，用于网络开发
4. java.awt.* -- 用于Java的界面GUI开发

打包和引入：

1. 类打包：`package com.bjtu.pkg;`声明当前类所属的包，要放在类的最上面，一个类中最多只能有一个`package`
2. 包引入：`import java.util.Scanner;`，应该用什么类就导入什么，不建议`import java.util.*`的方式

# 访问修饰符

Java提供四种访问修饰符，用于控制方法和属性的访问权限

1. 公开级别：`public`，对外公开
2. 受保护级别：`protected`，对子类和同一个包中的类公开
3. 默认级别：没有修饰符号，对同一个包的类公开
4. 私有级别：`private`，只有类本身可以访问，不对外公开

<img src="figures/image-20220812101141635.png" alt="image-20220812101141635" align="left" style="zoom: 50%;" />

**使用注意事项**

1. 修饰符可以用于修饰类中的属性、成员方法和类
2. 只有默认的和`public`才能修饰类
3. 成员方法的额访问规则和属性完全一样

# 封装

封装(encapsulation)就是把抽象出的数据（属性）和对数据的操作（方法）封装在一起，数据被保护在内部，程序的其他部分只有通过被授权的操作（方法），才能对数据进行操作。

封装的实现步骤：

1. 将属性进行私有化（private），不能直接修改属性
2. 提供一个公共的（public）set方法，用于对属性进行操作
3. 提供一个公共的（public）get方法，用于获取属性的值，在调用的时候还可以进行权限判断

手动编写`set`和`get`方法太慢，使用.idea的快捷键`alt+insert`，选择`Getter and Setter`

在构造器中调用`set`方法能够在创建对象时仍然保护属性

# 继承

继承可以解决代码复用，当多个类存在相同的属性（变量）和方法时，可以从类中抽象出父类，在父类中定义相同的属性和方法，所有的子类不需要重新定义属性和方法，只需要通过`extends`声明继承父类即可

继承基本语法：class 子类 extends 父类 {...}

1. 子类会自动拥有父类定义的属性和方法
2. 父类又叫做超类、基类；子类又叫做派生类

**使用细节和注意事项**

1. 子类继承了所有的属性和方法，但是私有属性不能在子类**直接访问**，要通过父类提供的公共方法去访问（疑问：既然要继承，这个机制究竟有什么用？）

2. 子类必须调用父类的构造器，完成父类的初始化

3. 在创建子类对象的时候，会自动调用父类的无参构造器，默认使用`super();`指令，类似Python中的`super`

   如果父类没有提供无参构造器，则必须在子类的构造器中使用`super(参数列表)`去指定使用父类的哪个构造器完成对父类的初始化操作，否则编译不会通过

4. `super`只能在构造器中使用，而且必须放在构造器第一行，由于`this()`必须在构造器第一行，因此一个构造器中`super()`和`this()`只能存在一个

5. Java所有类都是`Object`类的子类

6. 父类构造器的调用不限于直接父类，将一直往上追溯到`Object`类（顶级父类）

7. 子类最多只能继承一个父类（直接继承），即Java时单继承机制

8. 不能滥用继承，子类和父类之间必须满足 is-a 的逻辑关系

**super和this**

1. 访问属性和方法：
   1. this：访问本类中的属性，如果本类没有则从父类中继续查找
   2. super：从父类开始查找属性
2. 调用构造器：
   1. this：调用本类构造器，必须放在构造器的首行
   2. super：调用父类构造器，必须放在构造器的首行
3. 特殊：this表示当前对象，super在子类中访问父类对象

# Override

子类有一个方法和父类的某个方法名称、返回类型、参数相同，那么就会覆盖父类的方法，要求如下：

1. 子类的方法的参数、方法名称和父类方法的参数、方法名完全一样

2. 子类方法的返回类型和父类方法的返回类型相同，或者是**父类返回类型的子类**，例如：

   ```java
   public Object getInfo() {}
   public String getInfo() {} //String是Object的子类，因此同样构成方法重写
   ```

3. 子类方法不能缩小父类方法的访问权限，例如：

   ```java
   void sayOk() {}
   public void sayOk() {} // 访问权限public > protected > default > private
   ```

# 多态

多态指的是方法或者对象具有多种形态，是面向对象的第三大特征。多态是建立在封装和继承基础之上的

多态的具体体现：

1. 方法的多态，重写和重载就体现多态

   1. 重载：使用不同的参数列表就能够使用不同的函数功能
   2. 重写：调用不同类的函数能够使用不同的功能

2. 对象的多态（核心、重点）

   1. 一个对象的编译类型和运行类型可以不一致

      可以让父类的引用指向子类的对象，编译类型和运行类型不同，例如：

      ```java
      Animal animal = new Dog();
      ```

      这里的编译类型是`Animal`，运行类型是`Dog`

   2. 编译类型在定义对象时就确定了，不能改变

   3. 运行类型是可以变化的，例如：

      ```java
      animal = new Cat();
      ```

      这里的`animal`指向了`Cat`，但是它的编译类型依然是`Animal`，只是运行类型变成了`Cat`

   4. 编译类型看定义时 = 号的左边，运行类型看 = 号的右边

      从上文可以看出，编译类型为等号左边的`Animal`，运行类型是等号右边的`Dog`，后来又改成了`Cat`

   如果需要使用某个方法，方法中需要传入不同的子类作为参数，从而需要编写多个方法。那么可以将子类替换为父类，直接使用父类的属性和方法，因为父类可以兼容子类，这样就避免了编写多个函数，用一个函数就能解决。

   例如“宠物喂食”问题，动物大类中有多个子类：猫、狗、猪、鱼，食物大类也有多个子类：猫粮、骨头、饼干、米饭

   ```java
   public void feed(Animal animal, Food food) {
       System.out.println(animal.getName() + "吃" + food.getName())
   }
   ```

**注意事项和细节**

1. 多态的前提是：两个对象（类）存在继承关系；

2. 多态的**向上转型**：本质是父类的引用指向了子类的对象

3. 多态的**向下转型**：

   1. 语法：子类类型 引用名 = （子类类型）父类引用；例如：

      ```java
      Animal animal = new Dog();
      Dog dog = (Dog) animal;
      ```

      语法和强制类型转换基本相同

   2. 只能强转父类的引用，不能强转父类的对象

   3. 要求父类的引用必须指向的是当前目标类型的对象

   4. 可以调用子类类型中所有的成员

4. 属性没有重写之说，属性的值看**编译类型**，例如

   ```java
   class Base {int count = 10;}
   class Sub extends Base {int count = 20;}
   Base base = new Sub();
   System.out.println(base.count); //10
   ```

5. `instanceof`比较操作符，用于判断对象的**运行类型**是否为某类型或者某类型的子类型，例如

   ```java
   BB bb = new BB(); // BB extends AA，AA是父类
   System.out.println(bb instanceof BB); // true，对象是某类型
   System.out.println(bb instanceof AA); // true，对象是某类型的子类型
   AA aa = new BB(); // 运行类型是BB
   System.out.println(aa instanceof BB); // true，对象是某类型
   System.out.println(aa instanceof AA); // true，对象是某类型的子类型
   ```

## 动态绑定机制

1. 当调用对象方法时，该方法会和该对象的**内存地址（运行类型）绑定**
2. 当调用对象属性时，没有动态绑定机制，哪里声明就在哪里使用

## 多态的应用

1. 多态数组：数组的定义类型为父类类型，里面保存的实际元素类型为子类类型

   实例：要求创建1个Person对象、2个Student对象和2个Teacher对象，放在一个数组中，并调用每个对象的`say()`方法

   实例升级：如何调用子类特有的方法，例如Teacher的`teach()`和Student的`study()`

   ```java
   if (persons[i] instanceof Student) {
       (Student)persons[i].study();
   } else if (persons[i] instanceof Teacher) {
       (Teacher)persons[i].teach();
   } else {
       persons[i].say();
   }
   ```

   使用向下转型，即可实现调用不同子类对象特定的方法

2. 多态参数：方法定义的形参类型为父类类型，实参类型允许为子类类型

   实例1：之前的主人给动物喂食的例子

   实例2：定义员工类`Employee`，包含姓名和月工资[private]，以及计算年工资getAnnual的方法。普通员工和经理继承了员工，经理类多了奖金`bonus`属性和管理`manage`方法，普通员工类多了`work`方法，普通员工和经理类要求分别重写`getAnnual`方法

   测试类中添加一个方法`showEmpAnnual(Employee e)`，实现获取任何员工对象的年工资，并在main方法中调用该方法[e.getAnnual()]。 --> 在定义方法时输入父类对象，即可兼容各个子类对象并调用各自的方法

   测试类中添加一个方法`testWork`，如果是普通员工则调用`work`方法，如果是经理则调用`manage`方法 --> 这就是多态数组中案例所用到的方法

# Object类

位置：`java.lang.Object`，每个类都使用Object作为超类

方法摘要：equals, finalize, getclass, hashCode, toString等

1. `equals`：`==`和`equals`的对比：

   1. `==`既可以判断基本类型，又可以判断引用类型
   2. `==`如果判断基本类型，判断的是值是否相等
   3. `==`如果判断引用类型，则是判断地址是否相等，也就是判断是不是同一个对象
   4. `equals`是`Object`类的方法，只能判断引用类型
   5. `equals`默认判断的是地址是否相等，子类中往往会重写该方法，用于判断内容是否相等，比如`String`, `Integer`

2. `hashCode`：返回该对象的哈希码值，此方法是为了提高哈希表(java.util.HashTable)的性能

   1. 两个引用如果指向同一个对象，则哈希值相同，否则不同
   2. 哈希值主要根据地址计算而来，但不等价与地址
   3. 在集合中如果有需要的话会重写hashCode

3. `toString`：返回该对象的字符串表示，默认返回：全类名（包名+类名）+@+哈希值的十六进制

   ```java
   public String toString {
       getClass().getName() + "@" +Integer.toHexString(hashCode())
   }
   ```

4. `finalize`：当垃圾回收器确定不存在该对象的更多引用时，由对象的垃圾回收器调用此方法，子类可以重写此方法，做一些**释放资源**的操作，例如数据库的连接或者打开的文件

   



