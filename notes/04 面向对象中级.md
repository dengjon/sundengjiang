# 软件包

包的三个作用：

1. 区分相同名字的类
2. 当类很多时，使用包可以进行方便的管理
3. 控制访问范围

软件包的本质就是创建不同的文件夹来保存类

命名规范：

com.公司名.项目名.业务模块名，例如：`com.bjtu.oa.model;`

**常用包**

1. java.lang.* -- 默认引用，无须再导入
2. java.util.* -- 系统提供的工具包、工具类，例如`Scanner`
3. java.net.* -- 网络包，用于网络开发
4. java.awt.* -- 用于Java的界面GUI开发

打包和引入：

1. 类打包：`package com.bjtu.pkg;`声明当前类所属的包，要放在类的最上面，一个类中最多只能有一个`package`
2. 包引入：`import java.util.Scanner;`，应该用什么类就导入什么，不建议`import java.util.*`的方式

# 访问修饰符

Java提供四种访问修饰符，用于控制方法和属性的访问权限

1. 公开级别：`public`，对外公开
2. 受保护级别：`protected`，对子类和同一个包中的类公开
3. 默认级别：没有修饰符号，对同一个包的类公开
4. 私有级别：`private`，只有类本身可以访问，不对外公开

<img src="figures/image-20220812101141635.png" alt="image-20220812101141635" align="left" style="zoom: 50%;" />

**使用注意事项**

1. 修饰符可以用于修饰类中的属性、成员方法和类
2. 只有默认的和`public`才能修饰类
3. 成员方法的额访问规则和属性完全一样

# 封装

封装(encapsulation)就是把抽象出的数据（属性）和对数据的操作（方法）封装在一起，数据被保护在内部，程序的其他部分只有通过被授权的操作（方法），才能对数据进行操作。

封装的实现步骤：

1. 将属性进行私有化（private），不能直接修改属性
2. 提供一个公共的（public）set方法，用于对属性进行操作
3. 提供一个公共的（public）get方法，用于获取属性的值，在调用的时候还可以进行权限判断

手动编写`set`和`get`方法太慢，使用.idea的快捷键`alt+insert`，选择`Getter and Setter`

在构造器中调用`set`方法能够在创建对象时仍然保护属性

# 继承

继承可以解决代码复用，当多个类存在相同的属性（变量）和方法时，可以从类中抽象出父类，在父类中定义相同的属性和方法，所有的子类不需要重新定义属性和方法，只需要通过`extends`声明继承父类即可

继承基本语法：class 子类 extends 父类 {...}

1. 子类会自动拥有父类定义的属性和方法
2. 父类又叫做超类、基类；子类又叫做派生类

**使用细节和注意事项**

1. 子类继承了所有的属性和方法，但是私有属性不能在子类**直接访问**，要通过父类提供的公共方法去访问（疑问：既然要继承，这个机制究竟有什么用？）

2. 子类必须调用父类的构造器，完成父类的初始化

3. 在创建子类对象的时候，会自动调用父类的无参构造器，默认使用`super();`指令，类似Python中的`super`

   如果父类没有提供无参构造器，则必须在子类的构造器中使用`super(参数列表)`去指定使用父类的哪个构造器完成对父类的初始化操作，否则编译不会通过

4. `super`只能在构造器中使用，而且必须放在构造器第一行，由于`this()`必须在构造器第一行，因此一个构造器中`super()`和`this()`只能存在一个

5. Java所有类都是`Object`类的子类

6. 父类构造器的调用不限于直接父类，将一直往上追溯到`Object`类（顶级父类）

7. 子类最多只能继承一个父类（直接继承），即Java时单继承机制

8. 不能滥用继承，子类和父类之间必须满足 is-a 的逻辑关系

**super和this**

1. 访问属性和方法：
   1. this：访问本类中的属性，如果本类没有则从父类中继续查找
   2. super：从父类开始查找属性
2. 调用构造器：
   1. this：调用本类构造器，必须放在构造器的首行
   2. super：调用父类构造器，必须放在构造器的首行
3. 特殊：this表示当前对象，super在子类中访问父类对象

# Override

子类有一个方法和父类的某个方法名称、返回类型、参数相同，那么就会覆盖父类的方法，要求如下：

1. 子类的方法的参数、方法名称和父类方法的参数、方法名完全一样

2. 子类方法的返回类型和父类方法的返回类型相同，或者是**父类返回类型的子类**，例如：

   ```java
   public Object getInfo() {}
   public String getInfo() {} //String是Object的子类，因此同样构成方法重写
   ```

3. 子类方法不能缩小父类方法的访问权限，例如：

   ```java
   void sayOk() {}
   public void sayOk() {} // 访问权限public > protected > default > private
   ```

# 多态

多态指的是方法或者对象具有多种形态，是面向对象的第三大特征。多态是建立在封装和继承基础之上的

多态的具体体现：

1. 方法的多态，重写和重载就体现多态

   1. 重载：使用不同的参数列表就能够使用不同的函数功能
   2. 重写：调用不同类的函数能够使用不同的功能

2. 对象的多态（核心、重点）

   1. 一个对象的编译类型和运行类型可以不一致

      可以让父类的引用指向子类的对象，编译类型和运行类型不同，例如：

      ```java
      Animal animal = new Dog();
      ```

      这里的编译类型是`Animal`，运行类型是`Dog`

   2. 编译类型在定义对象时就确定了，不能改变

   3. 运行类型是可以变化的，例如：

      ```java
      animal = new Cat();
      ```

      这里的`animal`指向了`Cat`，但是它的编译类型依然是`Animal`，只是运行类型变成了`Cat`

   4. 编译类型看定义时 = 号的左边，运行类型看 = 号的右边

      从上文可以看出，编译类型为等号左边的`Animal`，运行类型是等号右边的`Dog`，后来又改成了`Cat`

   如果需要使用某个方法，方法中需要传入不同的子类作为参数，从而需要编写多个方法。那么可以将子类替换为父类，直接使用父类的属性和方法，因为父类可以兼容子类，这样就避免了编写多个函数，用一个函数就能解决。

   例如“宠物喂食”问题，动物大类中有多个子类：猫、狗、猪、鱼，食物大类也有多个子类：猫粮、骨头、饼干、米饭

   ```java
   public void feed(Animal animal, Food food) {
       System.out.println(animal.getName() + "吃" + food.getName())
   }
   ```

**注意事项和细节**

1. 多态的前提是：两个对象（类）存在继承关系；

2. 多态的**向上转型**：本质是父类的引用指向了子类的对象

3. 多态的**向下转型**：

   1. 语法：子类类型 引用名 = （子类类型）父类引用；例如：

      ```java
      Animal animal = new Dog();
      Dog dog = (Dog) animal;
      ```

      语法和强制类型转换基本相同

   2. 只能强转父类的引用，不能强转父类的对象

   3. 要求父类的引用必须指向的是当前目标类型的对象

   4. 可以调用子类类型中所有的成员

4. 属性没有重写之说，属性的值看**编译类型**，例如

   ```java
   class Base {int count = 10;}
   class Sub extends Base {int count = 20;}
   Base base = new Sub();
   System.out.println(base.count); //10
   ```

5. `instanceof`比较操作符，用于判断对象的**运行类型**是否为某类型或者某类型的子类型，例如

   ```java
   BB bb = new BB(); // BB extends AA，AA是父类
   System.out.println(bb instanceof BB); // true，对象是某类型
   System.out.println(bb instanceof AA); // true，对象是某类型的子类型
   AA aa = new BB(); // 运行类型是BB
   System.out.println(aa instanceof BB); // true，对象是某类型
   System.out.println(aa instanceof AA); // true，对象是某类型的子类型
   ```





