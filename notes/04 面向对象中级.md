# 软件包

包的三个作用：

1. 区分相同名字的类
2. 当类很多时，使用包可以进行方便的管理
3. 控制访问范围

软件包的本质就是创建不同的文件夹来保存类

命名规范：

com.公司名.项目名.业务模块名，例如：`com.bjtu.oa.model;`

**常用包**

1. java.lang.* -- 默认引用，无须再导入
2. java.util.* -- 系统提供的工具包、工具类，例如`Scanner`
3. java.net.* -- 网络包，用于网络开发
4. java.awt.* -- 用于Java的界面GUI开发

打包和引入：

1. 类打包：`package com.bjtu.pkg;`声明当前类所属的包，要放在类的最上面，一个类中最多只能有一个`package`
2. 包引入：`import java.util.Scanner;`，应该用什么类就导入什么，不建议`import java.util.*`的方式

# 访问修饰符

Java提供四种访问修饰符，用于控制方法和属性的访问权限

1. 公开级别：`public`，对外公开
2. 受保护级别：`protected`，对子类和同一个包中的类公开
3. 默认级别：没有修饰符号，对同一个包的类公开
4. 私有级别：`private`，只有类本身可以访问，不对外公开

<img src="figures/image-20220812101141635.png" alt="image-20220812101141635" align="left" style="zoom: 50%;" />

**使用注意事项**

1. 修饰符可以用于修饰类中的属性、成员方法和类
2. 只有默认的和`public`才能修饰类
3. 成员方法的额访问规则和属性完全一样

# 封装

封装(encapsulation)就是把抽象出的数据（属性）和对数据的操作（方法）封装在一起，数据被保护在内部，程序的其他部分只有通过被授权的操作（方法），才能对数据进行操作。

封装的实现步骤：

1. 将属性进行私有化（private），不能直接修改属性
2. 提供一个公共的（public）set方法，用于对属性进行操作
3. 提供一个公共的（public）get方法，用于获取属性的值，在调用的时候还可以进行权限判断

手动编写`set`和`get`方法太慢，使用.idea的快捷键`alt+insert`，选择`Getter and Setter`

在构造器中调用`set`方法能够在创建对象时仍然保护属性

# 继承

继承可以解决代码复用，当多个类存在相同的属性（变量）和方法时，可以从类中抽象出父类，在父类中定义相同的属性和方法，所有的子类不需要重新定义属性和方法，只需要通过`extends`声明继承父类即可

继承基本语法：class 子类 extends 父类 {...}

1. 子类会自动拥有父类定义的属性和方法
2. 父类又叫做超类、基类；子类又叫做派生类

**使用细节和注意事项**

1. 子类继承了所有的属性和方法，但是私有属性不能在子类**直接访问**，要通过父类提供的公共方法去访问（疑问：既然要继承，这个机制究竟有什么用？）

2. 子类必须调用父类的构造器，完成父类的初始化

3. 在创建子类对象的时候，会自动调用父类的无参构造器，默认使用`super();`指令，类似Python中的`super`

   如果父类没有提供无参构造器，则必须在子类的构造器中使用`super(参数列表)`去指定使用父类的哪个构造器完成对父类的初始化操作，否则编译不会通过

4. `super`只能在构造器中使用，而且必须放在构造器第一行，由于`this()`必须在构造器第一行，因此一个构造器中`super()`和`this()`只能存在一个

5. Java所有类都是`Object`类的子类

6. 父类构造器的调用不限于直接父类，将一直往上追溯到`Object`类（顶级父类）

7. 子类最多只能继承一个父类（直接继承），即Java时单继承机制

8. 不能滥用继承，子类和父类之间必须满足 is-a 的逻辑关系





