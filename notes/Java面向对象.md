# 类与对象

基本使用案例：

```java
class Cat {
    String name;
    int age;
    String color;
}
Cat cat1 = new Cat(); //创建一个对象
cat1.name = ...; //属性赋值
cat1.age = ...;
cat1.color = ...;
```

**注意事项**

`Person p2 =  p1;`其中`p1`是一个对象，类似数组的引用赋值，传递的是地址。

# 方法

定义和使用流程：

1. 在类中定义方法：

   ```java
   public void speak() {...} // public:方法公开; void:没有返回值; speak:方法名
   public int getSum(int num1, int num2) {
       ...;
       return ...;
   }
   ```

2. 创建对象后，直接调用方法：

   ```java
   Person p1 = new Person();//创建对象
   p1.speak(); //调用方法
   ```


**注意事项和使用细节**

1. 访问修饰符：控制方法使用的范围，包括`public`，`private`，`protected`，`default`
2. 返回类型：一个方法最多有一个返回值（但可以通过使用一些数据结构返回多个结果）
3. 如果方法要求有**返回数据类型**，则方法最后的执行语句必须为`return`，并且返回值类型和`return`的类型要一致
4. 如果无返回值，则不需要return，或者只有`return ;`，没有返回值

5. 向方法内传入参数时，数据类型必须**相同或者能够兼容**

## 传参机制

每次调用方法，就会开辟一个新的栈，对于不同的数据类型，传参结果不同

1. 对于基本数据类型，会在栈内创建新的数，方法内对变量的修改不会影响到外部的变量

2. 对于引用类型（例如数组），由于传入的是数组的地址，那么方法内的修改会**影响到外部**

   **注意：**方法内部的形参可以改变堆中的数据（调用地址找到的数据），这样会影响外部的实参；但是如果改变地址的话，则不会影响外部的实参，因为原地址指向的数据空间中的内容并没有改变，只是改变了地址。例如

   ```java
   Person p = new Person();
   p.age = 10;
   b.test(p);
   System.out.println(p.age); // 10
   ...;
   public void test(Person p) {
       p = null; //只改变形参p的地址，不改变数据空间中的内容
   }
   ```


## 重载(overload)

Java中允许同一个类，多个同名方法的存在，但是要求**形参列表不一致**

例如`System.out.println`可以输出各种类型的数据，原因在于`System.out`是一个`PrintStream`的类型，其中包含多个`println`函数，但是各个函数的形参不同（数据类型），如果完全一样就是方法重名了

重载的优点：避免了重复起名字和记名字的麻烦

重载方法在使用时，程序会根据调用时的参数类型、数量自动检索匹配的方法

**注意事项和使用细节**

1. 方法名一定要一样
2. 参数列表必须不同：参数类型不同、顺序不同、数量不同，参数名无要求
3. 返回类型：无要求

## 可变参数

Java允许将同一个类中多个**同名**、**同功能**、**参数个数不同**的方法，封装成一个方法

基本语法：访问修饰符 返回类型 方法名（数据类型... 形参名）{}，例如

```java
public int sum(int... nums) { //这里的 int... 是固定用法，表示接收可变参数，类似Python中的*args
    int res = 0;
    for (int i=0; i < nums.length; i++) {
        res += nums[i]; // 接收进来的参数作为数组来使用
    }
    return 0;
}
```

**注意事项和使用细节**

1. 可变参数的实参可以是0或者任意多个
2. 可变参数本质就是数组
3. 可变参数的实参可以是数组
4. 可变参数可以和普通类型的参数一起放在形参列表，但是必须保证可变参数在最后
5. 一个形参列表只能出现一个可变参数

> 可变参数就类似Python中的*args，尤其是4，5两点，必须放在参数列表的最后，而且只能有一个

# 变量作用域

1. 在Java编程中，主要的变量就是属性（成员变量）和局部变量
2. 局部变量一般指在成员方法中定义的变量
3. Java中作用域的分类：全局变量--属性，作用域为整个类；局部变量--除了属性之外的其他变量，作用域为定义它的代码块中
4. 全局变量可以不赋值直接使用，因为它有默认值，局部变量必须赋值之后才能使用，因为没有默认值

**注意事项和细节**

1. 属性和局部变量可以重名，访问时遵循就近原则，也就是如果方法内定义了，就用方法内的，否则用属性值

2. 属性生命周期长，随着对象的销毁而销毁；局部变量生命周期短，伴随代码块的执行而创建，伴随代码块的结束而销毁，也就是说只在一次方法调用过程中存在。

3. 作用域范围不同：

   1. 全局变量：可以被本类使用，也可以被其他类使用（通过对象调用）
   2. 局部变量：只能在本类中对应方法中使用

4. 修饰符不同：

   1. 全局变量/属性可以加修饰符，例如：

      ```java
      private int age = 20;
      public double num = 1.5;
      ```

   2. 局部变量不可以加修饰符

# 构造方法/构造器

在创建对象的时候直接指定对象的属性

基本语法：[修饰符] 方法名（形参列表） {方法体}

**使用事项和细节**

1. 构造器没有**返回值**
2. 方法名和类名必须相同
3. 参数列表和成员方法一样的规则
4. 构造器的调用系统完成
5. 如果没有定义构造器，系统则会自动生成一个自动无参构造器，例如`Person(){}`
6. 一旦定义了自己的构造器，默认的构造器就被覆盖了

# this关键字

问题情景：

```java
class Dog {
    String name;
    int age;
    public Dog(String name, int age) {
        name = name;
        age = age;
    }
}// name=null; age=0;
```

> 希望构造器的变量名能使用属性名，并且还想给属性赋值

解决方式：非常类似Python中的`self`

```java
public Dog(String name, int age) {
    this.name = name;
    this.age = age;
}
```

**注意事项和细节**

1. this的本质是一个指向自己地址的指针，因此使用`this`就可以直接调用对象本身的属性
2. this可以访问构造器语法： this(参数列表) ；这种用法只能在构造器中使用，也就是只能在构造器中访问另外一个构造器

练习题：

```java
import java.util.Random;
...;
Random r = new Random();
comGuessNum = r.nextInt(3); //返回0-2的随机数
```



