# 类变量和类方法

## 类变量

类变量也叫做静态变量（静态属性），是一个类所有对象共享的变量，任何一个对象都可以访问，并且得到相同的值，同时所有该类的对象都可以去修改它。

语法：访问修饰符 static 数据类型 变量名;

**注意事项与使用细节**

1. 使用场景：当需要让某个类的所有对象共享一个变量时，即可使用类变量。

   例如统计所有学生交的学费：`Student(name, static fee)`

2. 类变量与实例变量区别：类变量所有对象共享，实例变量时一个对象独享

3. 使用`static`声明类变量，否则为实例变量/普通变量/非静态变量

4. 访问类变量方式：

   1. 类名.类变量名（推荐）
   2. 对象名.类变量名

5. 类变量在**类加载时就初始化**了，即使没有创建对象，只要类加载了就可以使用类变量

## 类方法

类方法也叫做静态方法，使用语法如下：

1. 访问修饰符 static 数据返回类型 方法名() {} （推荐）
2. static 访问修饰符 数据返回类型 方法名() {} 

类方法调用方式：类名.类方法名 或者 对象名.类方法名

使用场景：当方法中不涉及到任何和对象相关的成员，可以将方法设计成静态方法，提高开发效率，例如工具类中的方法`Math`，`Arrays`，`Collections`等，不需要创建对象就可以使用

**注意事项与使用细节**

类方法和普通方法都是随着类的加载而加载，将结构信息存在方法区

类方法中无this参数，普通方法中隐含着this参数。（就像Python中@staticmethod之后就无法用self调用）

# main方法

1. **Java虚拟机**调用类的`main()`方法，所以该方法的访问权限必须是`public`，因为Java虚拟机在调用时和程序不在一个类

2. `main`方法在调用的时候不需要创建对象，因此必须是`static`

3. 该方法接收`String`类型的数组参数，该数组中保存执行java命令时传递给所运行类的参数（**运行时**）

4. java 执行的程序 参数1 参数2 参数3，执行程序时将参数打包成字符串数组传进去，例如：

   ```shell
   java Hello jack alex rose
   ```

**注意事项和使用细节**

1. 在main方法中，可以直接调用main方法所在类的静态方法或者静态属性
2. 不能直接访问该类中的非静态成员，必须创建该类的一个实例对象后，才能通过对象去访问非静态成员

# 代码块

代码块又称为初始化块，属于类中的成员，将逻辑语句封装在方法体中，通过{}包围起来

代码块和方法不同，没有方法名和返回值，也没有参数，只有方法体，而且不用通过对象或者类显式调用，而是在加载类时或者创建对象时隐式调用。

基本语法： [修饰符] { 代码 };

**本质理解**

1. 代码块相当于另一种形式的构造器（对构造器的补充机制），可以做初始化的操作
2. 使用场景：如果多个构造器中都有重复的语句，可以抽取到初始化块中，提高代码的重用性

**注意事项和使用细节**

1. 代码块分两类，使用static修饰的称作静态代码块，没有static修饰的叫做普通代码块/非静态代码块，随着**类的加载**而执行，并且之惠**执行一次**。如果是普通代码块，每创建一个对象就执行

   问题：类什么时候被加载？**（重要）**

   1. 创建对象实例时（new）
   2. 创建子类对象实例时，父类也会被加载
   3. 使用类的静态成员时（静态属性，静态方法）

2. 在调用类的静态成员时，普通代码块不会被执行

3. 逻辑语句可以为任何逻辑语句（输入、输出、方法调用、循环、判断等）

4. ;号可以写可以不写，建议写上

5. 创建一个对象时，在一个类中的调用顺序：（重点，难点）

   1. 调用静态代码块和静态属性初始化（调用优先级一样，如果有多个静态代码块和多个静态属性初始化，按照定义的顺序调用）
   2. 调用普通代码块和普通属性初始化（调用优先级一样，如果有多个...，按照定义顺序调用）
   3. 调用构造方法

6. 构造器的最前面其实隐含了super()和调用普通代码块。而静态的代码块、属性初始化，在类加载时就执行完毕了，因此是优先于构造器和普通代码块执行，并且由于super和普通代码块在构造器最前面，因此构造方法的调用优先级最低

7. 在创建子类时（继承关系）时，静态/普通代码块、静态/普通属性初始化、构造方法的调用顺序：

   1. 父类的静态代码块和静态属性（优先级一样，按定义顺序执行）
   2. 子类的静态代码块和静态属性
   3. 父类的普通代码块和普通属性
   4. 父类的构造方法
   5. 子类的普通代码块和普通属性初始化
   6. 子类的构造方法

8. 静态代码块只能直接调用静态成员，普通代码块可以调用任意成员

# 单例设计模式

设计模式的概念：

1. 静态方法和属性的经典使用
2. 在大量实践中总结出的理论化后优选的代码结构、编程风格以及解决问题的思考方式

单例模式的概念：

1. 采用一定的方法保证在整个软件系统中，对某个类只能存在一个对象实例，并且该类只能提供一个取得其对象实例的方法，也就是在软件运行过程中某个类只能有一个实例。

   使用场景：某个耗用资源的核心类只创建一个实例

2. 单例模式的两种方式：饿汉式和懒汉式

**饿汉式具体步骤**：

1. 构造器私有化，用于防止用户直接`new`一个对象

2. 在类的内部创建对象

3. 向外暴露一个静态的公共方法。getInstance，例如：

   ```java
   class Test {
       private Test () {}
       private static Test instance = new Test();
       public static Test getInstance() { // 用static方法调用static对象
           return instance;
       }
   }
   ```

4. 代码实现

**懒汉式具体步骤：**

1. 构造器私有化

2. 定义一个static静态属性对象

3. 提供一个public static方法，可以返回一个对象

4. 代码实现，例如：

   ```java
   class Test {
       private Test() {};
       private static Test test; // 定义对象，但不创建
       public static Test getInstance() {
           if (test == null) { // 只有在第一次被调用的时候才会创建对象
               test = new Test();
           }
           return test;
       }
   }
   ```

**饿汉式vs懒汉式**

1. 主要区别在于创建对象的时机不同，饿汉式时在类加载时就创建对象实例，懒汉式是在使用时创建
2. 饿汉式不存在线程安全问题（？），懒汉式存在线程安全问题
3. 饿汉式存在资源浪费可能，懒汉式不存在
4. 在javaSE标准类中，java.lang.Runtime就是经典的单例模式

# final关键字

final可以修饰类、属性、方法和局部变量

使用场景：

1. 不希望类被继承时，可以用final修饰，例如某个类比较重要，不希望被继承重写产生bug
2. 当不希望父类的某个方法被子类覆盖/重写（override）
3. 当不希望类的某个属性的值被修改，可以用final修饰（不允许重新分配值），对于数组来说并不影响修改内部的元素，因为变量的值只是一个地址，只要不修改地址就没关系
4. 当不希望某个局部变量被修改

**注意事项和细节**

1. final修饰的属性又叫做常量，一般用XX_XX_XX来命名（字母全部都是大写，使用规范）
2. final修饰的属性在定义时，必须进行初始化，并且以后不可以再修改，赋值的位置可以是：
   1. 定义时，例如`public final double TAX_RATE=0.9`
   2. 在构造器中
   3. 再代码块中
3. 如果final修饰的属性是静态的，则初始化的位置只能是1. 定义时；2. 静态代码块，**不能在构造器中赋值**
4. final类不能继承，但是可以实例化对象
5. 如果类不是final类但是包含final的方法，那么虽然不能被重写，但是可以被继承
6. 一般来说如果一个类已经是final类，那么就没必要把方法修饰成final方法
7. final不能修饰构造方法（即构造器）
8. final和static往往搭配使用，效率更高，因为底层编译器做了优化处理，不会导致类加载。如果只是想调用属性和方法，不希望属性加载，就可以两个搭配使用
9. 包装类（Integer, Double, Float, Boolean等）以及String都是final类，不能被继承

# 抽象类

抽象类基本概念

1. 用`abstract`关键字修饰一个类，那么这个类就是抽象类，例如`abstract class A {}`

2. 如果用abstract来修饰一个方法，这个方法就是抽象方法（没有方法体），例如：

   ```java
   public abstract void eat();
   ```

3. 抽象类的价值更多是在于设计，设计好之后让子类继承并实现。大部分的设计模式中都会用到抽象类

**注意事项与使用细节**

1. 抽象类不能被实例化
2. 抽象类不一定要包含抽象方法，还可以有实现的方法，也就是说一个抽象类里也可以有具体的程序
3. 一个类**包含了抽象方法，必须把它声明为抽象类**
4. abstract关键字只能修饰类和方法，不能修饰属性和其他
5. 抽象类可以有任意成员（因为抽象类还是类），比如非抽象方法、构造器、静态属性等
6. 抽象方法不能有主体，也就是不能有{}
7. 如果一个类继承了抽象类，那么就必须实现抽象类里的所有抽象方法，除非它自己也声明为抽象类
8. 抽象方法**不能使用private, final, static来修饰**，因为这些关键字都是和重写相违背的

# 接口

接口就是给出一些没有实现的方法，封装到一起，到某个类要使用的时候再根据具体情况把这些方法写出来

语法： interface 接口名 {属性，方法}；class 类名 implements 接口 {自己属性；自己方法；必须实现的抽象方法}

注：在jdk7.0前，接口里的方法都没有方法体，都是抽象方法，jdk8.0后接口可以有静态方法，默认方法，也就是说接口中可以有方法的具体实现，但是需要用`default`关键字修饰，也可以有静态方法

**注意事项和细节**

1. 接口不能被实例化，因为接口是一种特别的抽象类

2. 接口中所有的方法都是public方法，接口中抽象方法可以不用`abstract`修饰

3. 一个普通类实现接口，就必须将该接口的所有方法都实现（快捷键：alt+enter）

4. 抽象类实现接口，可以不用实现接口的方法

5. 一个类同时可以实现多个接口

6. 接口中的属性只能是final的，而且是`public static final`修饰符，比如`int a = 1;`，实际上是`public static final int a = 1`，只是前面的修饰符被隐藏了，因为能够凭借接口直接访问属性，就说明属性是`static`的，而且接口的存在意义就是提供一个模板，本来就不应该被修改，因此应该是`final`的

7. 接口不能继承其他的类，但是可以继承多个别的接口，例如

   ```java
   interface A extends B, C {}
   ```

8. 接口中的修饰符必须是`public`或者默认，这一点和类的修饰符是一样的

## 实现接口 vs 继承类

接口是继承的补充，因为子类只能继承一个父类（单继承），而接口则可以实现多继承

1. 接口和继承解决的问题不同

   继承的价值在于：解决代码的复用性和可维护性

   接口的价值在于：设计各种规范方法，让其他类去实现这些方法

2. 接口比继承更加灵活

   继承满足is - a 的关系，而接口只需要满足like - a的关系

3. 接口在一定程度上实现代码解耦（即 接口规范性+动态绑定）

## 接口的多态特性

1. 多态参数

2. 多态数组

3. 接口存在多态传递现象

   ```java
   interface IH {}
   interface IG extends IH {}
   class Teacher implements IG {}
   IG ig = new Teacher();
   IH ih = new Teacher(); // IG继承IH接口，那么IH同样可以使用多态
   ```

# 内部类

一个类的内部又完整地嵌套了另一个类结构，被嵌套的类称为内部类（inner class），嵌套其他类的类称为外部类（outer class）。

类的五大成员：属性、方法、构造器、代码块、内部类，例如：

```java
class Outer {
    private int n1 = 100; //属性
    public Outer(int n1) {//构造器
        this.n1 = n1;
    }
    public void m1() {} //方法
    {
        ...;//代码块
    }
    class Inner {} //内部类，在Outer类的内部
}
```

**内部类的分类：**

1. 定义在外部类的局部位置上（例如方法内）：
   1. 局部内部类（有类名）
   2. 匿名内部类（没有类名，**重点**）
2. 定义在外部类的成员位置上
   1. 成员内部类（没用static修饰）
   2. 静态内部类（使用static修饰）

## 局部内部类

局部内部类是定义在外部类的局部位置，例如方法中，并且有类名

1. 可以直接访问外部类的所有成员，包括私有的

2. 不能添加访问修饰符，因为它的地位就是一个**局部变量**，但是可以使用final修饰，因为局部变量也可以使用final，那么类就不能被继承，因为继承类的目的就是为了修改

3. 作用域：仅仅在定义它的方法或代码块中

4. 局部内部类可以直接访问外部类的成员

5. 外部类在方法中要访问局部内部类的成员，访问方式为：创建对象，再访问**（必须在作用域内**）

6. 外部其他类不能访问局部内部类，因为局部内部类是一个局部变量

7. 如果外部类和局部内部类的成员重名时（即在内部类中创建一个名称与外部类属性名相同的属性），默认遵循就近原则，如果想访问外部类的成员，则可以使用 （外部类名.this.成员）去访问

   ```java
   class Outer {
       private int n1 = 100;
       final class Inner{
           private int n1 = 800;
           public void f1() {
               System.out.println(Outer.this.n1); //调用外部类的属性，外部类名.this.成员
           }
       }
   }
   ```

   这么做的意义在于区分本类和外部类，因为内部类也是一个类，也有`this`方法，使用 外部类名.this.成员的方式能够指定调用外部类的成员

## 匿名内部类***

匿名内部类是定义在外部类的局部位置（例如方法）中的类，并且没有类名

本质：（1）本质是类；（2）内部类；（3）没有名字（底层分配名字）；（4）同时还是一个对象

基本语法： new 类或接口（参数列表）{ 类体 };

**基于接口的匿名内部类**

1. 需求：想使用一个接口`IA`，并创建对象

2. 传统方式：写一个类，实现该接口，并创建对象

3. 新需求：一个类只想使用一次，以后不再使用

4. 解决方案：使用匿名内部类来简化开发，代码举例：

   ```java
   class Outer {
       public void f1() {
           IA tiger = new IA() { // IA 是一个接口
               @override
               public void cry() {
                   System.out.println("...");
               }
           };
           tiger.cry();
       }
   }
   ```

   `tiger`的编译类型是`IA`，运行类型是**匿名内部类**，名称为 外部类名$1，底层实现了：

   ```java
   class Outer$1 implements IA {...}
   ```

   并且**创建实例**，把地址返回给了`tiger`

5. 匿名内部类只能使用一次，因为在底层实现类并返回实例之后，类就找不到了，只能使用实例

**基于类的匿名内部类**

可以重写类的方法并传入参数（构造器），例如：

```java
Father father = new Father("jack") {
    @Override
    public void test() {
        ...;
    }
};
father.test();
```

匿名内部类是继承了原来的父类，然后重写成员方法，同时也可以调用父类的方法

**注意事项与使用细节**

1. 匿名内部类可以直接调用，可以不接收实例的地址，例如：

   ```java
   new Person() {
       @Override
       public void hi() {
           ...;
       }
   }.hi();
   ```

2. 可以**直接访问**外部类的所有成员，包含私有的

## 成员内部类

成员内部类是定义在外部类的成员位置，并且没有`static`修饰

1. 可以访问外部类的所有成员，包括私有的

2. 可以添加任意访问修饰符（public, protected, 默认, private）因为它的地位就是成员

3. 外部其他类，使用成员内部类的两种方式：

   1. ```java
      Outer.Inner inner = Outer.new Inner();
      ```

   2. ```java
      public Inner getInnerInstance() {
          return new Inner();
      }//在外部类中定义一个返回内部类实例的方法
      ```

4. 如果外部类和内部类成员重名，遵守就近原则，同上【局部内部类】

## 静态内部类

静态内部类是定义在外部类的成员位置，并且有`static`修饰

1. 可以直接访问外部类的所有静态成员，包括私有的，但是不能访问非静态成员

2. 可以添加访问修饰符（...）

3. 作用域：同其他成员

4. 外部类访问静态内部类的方式：创建对象，再访问

5. 外部其他类访问静态内部类的方式：

   1. ```java
      Outer.Inner inner = new Outer.Inner();
      ```

      直接通过类去访问并创建，而不需要`Outer.new Inner()`，前提是满足访问权限

   2. 编写一个能够返回内部类实例的方法，例如：

      ```java
      public static Inner getInnerInstance() {
          return new Inner();
      }
      ```

6. 如果外部类和静态内部类成员重名时，默认遵循就近原则，如果要访问外部类成员，则可以使用**外部类名.成员**去访问，因为内部类是静态的，因此不能使用`this`







