# 类变量和类方法

## 类变量

类变量也叫做静态变量（静态属性），是一个类所有对象共享的变量，任何一个对象都可以访问，并且得到相同的值，同时所有该类的对象都可以去修改它。

语法：访问修饰符 static 数据类型 变量名;

**注意事项与使用细节**

1. 使用场景：当需要让某个类的所有对象共享一个变量时，即可使用类变量。

   例如统计所有学生交的学费：`Student(name, static fee)`

2. 类变量与实例变量区别：类变量所有对象共享，实例变量时一个对象独享

3. 使用`static`声明类变量，否则为实例变量/普通变量/非静态变量

4. 访问类变量方式：

   1. 类名.类变量名（推荐）
   2. 对象名.类变量名

5. 类变量在**类加载时就初始化**了，即使没有创建对象，只要类加载了就可以使用类变量

## 类方法

类方法也叫做静态方法，使用语法如下：

1. 访问修饰符 static 数据返回类型 方法名() {} （推荐）
2. static 访问修饰符 数据返回类型 方法名() {} 

类方法调用方式：类名.类方法名 或者 对象名.类方法名

使用场景：当方法中不涉及到任何和对象相关的成员，可以将方法设计成静态方法，提高开发效率，例如工具类中的方法`Math`，`Arrays`，`Collections`等，不需要创建对象就可以使用

**注意事项与使用细节**

类方法和普通方法都是随着类的加载而加载，将结构信息存在方法区

类方法中无this参数，普通方法中隐含着this参数。（就像Python中@staticmethod之后就无法用self调用）

# main方法

1. **Java虚拟机**调用类的`main()`方法，所以该方法的访问权限必须是`public`，因为Java虚拟机在调用时和程序不在一个类

2. `main`方法在调用的时候不需要创建对象，因此必须是`static`

3. 该方法接收`String`类型的数组参数，该数组中保存执行java命令时传递给所运行类的参数（**运行时**）

4. java 执行的程序 参数1 参数2 参数3，执行程序时将参数打包成字符串数组传进去，例如：

   ```shell
   java Hello jack alex rose
   ```

**注意事项和使用细节**

1. 在main方法中，可以直接调用main方法所在类的静态方法或者静态属性
2. 不能直接访问该类中的非静态成员，必须创建该类的一个实例对象后，才能通过对象去访问非静态成员

# 代码块

代码块又称为初始化块，属于类中的成员，将逻辑语句封装在方法体中，通过{}包围起来

代码块和方法不同，没有方法名和返回值，也没有参数，只有方法体，而且不用通过对象或者类显式调用，而是在加载类时或者创建对象时隐式调用。

基本语法： [修饰符] { 代码 };

**本质理解**

1. 代码块相当于另一种形式的构造器（对构造器的补充机制），可以做初始化的操作
2. 使用场景：如果多个构造器中都有重复的语句，可以抽取到初始化块中，提高代码的重用性

**注意事项和使用细节**

1. 代码块分两类，使用static修饰的称作静态代码块，没有static修饰的叫做普通代码块/非静态代码块，随着**类的加载**而执行，并且之惠**执行一次**。如果是普通代码块，每创建一个对象就执行

   问题：类什么时候被加载？**（重要）**

   1. 创建对象实例时（new）
   2. 创建子类对象实例时，父类也会被加载
   3. 使用类的静态成员时（静态属性，静态方法）

2. 在调用类的静态成员时，普通代码块不会被执行

3. 逻辑语句可以为任何逻辑语句（输入、输出、方法调用、循环、判断等）

4. ;号可以写可以不写，建议写上

5. 创建一个对象时，在一个类中的调用顺序：（重点，难点）

   1. 调用静态代码块和静态属性初始化（调用优先级一样，如果有多个静态代码块和多个静态属性初始化，按照定义的顺序调用）
   2. 调用普通代码块和普通属性初始化（调用优先级一样，如果有多个...，按照定义顺序调用）
   3. 调用构造方法

6. 构造器的最前面其实隐含了super()和调用普通代码块。而静态的代码块、属性初始化，在类加载时就执行完毕了，因此是优先于构造器和普通代码块执行，并且由于super和普通代码块在构造器最前面，因此构造方法的调用优先级最低

7. 在创建子类时（继承关系）时，静态/普通代码块、静态/普通属性初始化、构造方法的调用顺序：

   1. 父类的静态代码块和静态属性（优先级一样，按定义顺序执行）
   2. 子类的静态代码块和静态属性
   3. 父类的普通代码块和普通属性
   4. 父类的构造方法
   5. 子类的普通代码块和普通属性初始化
   6. 子类的构造方法

8. 静态代码块只能直接调用静态成员，普通代码块可以调用任意成员

# 单例设计模式

设计模式的概念：

1. 静态方法和属性的经典使用
2. 在大量实践中总结出的理论化后优选的代码结构、编程风格以及解决问题的思考方式

单例模式的概念：

1. 采用一定的方法保证在整个软件系统中，对某个类只能存在一个对象实例，并且该类只能提供一个取得其对象实例的方法，也就是在软件运行过程中某个类只能有一个实例。

   使用场景：某个耗用资源的核心类只创建一个实例

2. 单例模式的两种方式：饿汉式和懒汉式

**饿汉式具体步骤**：

1. 构造器私有化，用于防止用户直接`new`一个对象

2. 在类的内部创建对象

3. 向外暴露一个静态的公共方法。getInstance，例如：

   ```java
   class Test {
       private Test () {}
       private static Test instance = new Test();
       public static Test getInstance() { // 用static方法调用static对象
           return instance;
       }
   }
   ```

4. 代码实现

**懒汉式具体步骤：**

1. 构造器私有化

2. 定义一个static静态属性对象

3. 提供一个public static方法，可以返回一个对象

4. 代码实现，例如：

   ```java
   class Test {
       private Test() {};
       private static Test test; // 定义对象，但不创建
       public static Test getInstance() {
           if (test == null) { // 只有在第一次被调用的时候才会创建对象
               test = new Test();
           }
           return test;
       }
   }
   ```

**饿汉式vs懒汉式**

1. 主要区别在于创建对象的时机不同，饿汉式时在类加载时就创建对象实例，懒汉式是在使用时创建
2. 饿汉式不存在线程安全问题（？），懒汉式存在线程安全问题
3. 饿汉式存在资源浪费可能，懒汉式不存在
4. 在javaSE标准类中，java.lang.Runtime就是经典的单例模式

# final关键字

final可以修饰类、属性、方法和局部变量

使用场景：

1. 不希望类被继承时，可以用final修饰，例如某个类比较重要，不希望被继承重写产生bug
2. 当不希望父类的某个方法被子类覆盖/重写（override）
3. 当不希望类的某个属性的值被修改，可以用final修饰（不允许重新分配值），对于数组来说并不影响修改内部的元素，因为变量的值只是一个地址，只要不修改地址就没关系
4. 当不希望某个局部变量被修改

**注意事项和细节**

1. final修饰的属性又叫做常量，一般用XX_XX_XX来命名（字母全部都是大写，使用规范）
2. final修饰的属性在定义时，必须进行初始化，并且以后不可以再修改，赋值的位置可以是：
   1. 定义时，例如`public final double TAX_RATE=0.9`
   2. 在构造器中
   3. 再代码块中
3. 如果final修饰的属性是静态的，则初始化的位置只能是1. 定义时；2. 静态代码块，**不能在构造器中赋值**
4. final类不能继承，但是可以实例化对象
5. 如果类不是final类但是包含final的方法，那么虽然不能被重写，但是可以被继承
6. 一般来说如果一个类已经是final类，那么就没必要把方法修饰成final方法
7. final不能修饰构造方法（即构造器）
8. final和static往往搭配使用，效率更高，因为底层编译器做了优化处理，不会导致类加载。如果只是想调用属性和方法，不希望属性加载，就可以两个搭配使用
9. 包装类（Integer, Double, Float, Boolean等）以及String都是final类，不能被继承



